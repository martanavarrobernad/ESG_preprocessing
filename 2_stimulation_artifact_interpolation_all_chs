# -*- coding: utf-8 -*-
"""
Stimulation artifact removal (PCHIP) on all analog channels (EEG, ESG, ECG, ENG, etc.)

Pipeline:
1. Use cfg_artifact_windows_cervical.csv for subject-specific artifact windows.
2. Load each original EEGLAB .set file (10 kHz) from the local BIDS directory.
3. For each stimulus, interpolate the window [start_ms, end_ms] on all channels
   except stimulus/misc channels (based on channel type information in the dataset).
4. Save one .fif file per run:
   "noStimart_10kHz_task-<TASK>_run-<XX>.fif"
"""

from pathlib import Path
import re

import numpy as np
import pandas as pd
import mne
from scipy.interpolate import PchipInterpolator

# ==== 1) PATHS (ADJUST THIS PART IF NEEDED) ====

# Root of your BIDS dataset (ds004388-1.0.0) on your local machine
BASE = Path(r"C:\Users\navar\Desktop\ds004388-1.0.0")

# CSV with subject-specific artifact windows (produced by the previous script)
CFG_WIN_CSV = BASE / "cfg_artifact_windows_cervical.csv"

# Output directory for artifact-cleaned data
OUT_DIR = BASE / "eeg_esg_10kHz_noStimart"
OUT_DIR.mkdir(exist_ok=True, parents=True)

TASK_NAME = "median"


# ==== 2) HELPER FUNCTIONS ====


def find_subject_runs(rawdir: Path, subject: int, task: str):
    """Return all BIDS EEGLAB .set files for a given subject and task."""
    subject_id = f"sub-{subject:03d}"
    eeg_dir = rawdir / subject_id / "eeg"
    return sorted(eeg_dir.glob(f"{subject_id}_task-{task}_run-*_eeg.set"))


def read_events_tsv(events_tsv: Path):
    """
    Return stimulus onsets (in seconds) for events labeled as
    'stim', 'pulse' or 'median', or None if nothing is found.
    """
    if not events_tsv.exists():
        return None

    df = pd.read_csv(events_tsv, sep="\t")
    if "onset" not in df.columns:
        return None

    # 1) Prefer trial_type containing 'stim', 'pulse' or 'median'
    if "trial_type" in df.columns:
        mask = df["trial_type"].astype(str).str.lower().str.contains(r"(stim|pulse|median)")
        on = df.loc[mask, "onset"].values
        if on.size:
            return on.astype(float)

    # 2) Fallback: use the most frequent event code in "value"
    if "value" in df.columns and df["value"].notna().any():
        vv = df["value"].value_counts().idxmax()
        return df.loc[df["value"] == vv, "onset"].values.astype(float)

    return None


def interpolate_stim_artifact(raw, onsets, start_ms, end_ms, picks, n_pad=5):
    """
    Interpolate the stimulation artifact using PCHIP for selected channels.

    Parameters
    ----------
    raw : mne.io.Raw
        Raw object containing data.
    onsets : array-like
        Stimulus onsets in seconds.
    start_ms, end_ms : float
        Artifact window relative to each stimulus (in milliseconds).
    picks : list of str
        Channel names to clean (all analog channels except stim/misc).
    n_pad : int
        Number of samples before and after the artifact window used
        to build the PCHIP interpolant.
    """
    if not picks:
        return

    sf = raw.info["sfreq"]
    data = raw._data  # shape (n_channels, n_times)

    # Channel indices corresponding to the given names
    ch_indices = [raw.ch_names.index(ch) for ch in picks if ch in raw.ch_names]
    if len(ch_indices) == 0:
        return

    s0 = int(round(start_ms / 1000 * sf))
    s1 = int(round(end_ms / 1000 * sf))
    n_times = data.shape[1]

    for ons in onsets:
        idx_stim = int(round(ons * sf))
        i0 = idx_stim + s0
        i1 = idx_stim + s1

        # Skip if the window is outside the data range
        if i0 <= 0 or i1 >= n_times - 1:
            continue

        # Known points (before and after the artifact gap)
        before = np.arange(i0 - n_pad, i0)
        after = np.arange(i1 + 1, i1 + 1 + n_pad)
        x_known = np.concatenate([before, after])

        if x_known.min() < 0 or x_known.max() >= n_times:
            continue

        x_interp = np.arange(i0, i1 + 1)

        for ch in ch_indices:
            y_known = data[ch, x_known]

            # If the segment is almost flat, fill with mean value
            if np.allclose(y_known, y_known[0]):
                data[ch, i0:i1 + 1] = y_known.mean()
            else:
                f = PchipInterpolator(x_known, y_known)
                data[ch, i0:i1 + 1] = f(x_interp)


# ==== 3) MAIN PROGRAM ====


def main():
    # 1) Read CSV with artifact windows
    if not CFG_WIN_CSV.exists():
        print("Artifact-window CSV not found:", CFG_WIN_CSV)
        return

    cfg = pd.read_csv(CFG_WIN_CSV)
    cfg = cfg.set_index("subject")  # subject values: 1, 2, ...

    # 2) Loop over subjects defined in the CSV
    for s in cfg.index:
        subject_id = f"sub-{s:03d}"

        try:
            start_ms = float(cfg.loc[s, "start_cerv_ms"])
            end_ms = float(cfg.loc[s, "end_cerv_ms"])
        except Exception:
            print(f"{subject_id}: no artifact window defined in CSV, skipping.")
            continue

        print(f"\n===== {subject_id} =====")
        print(f"Artifact window: {start_ms:.3f} ms â†’ {end_ms:.3f} ms")

        setfiles = find_subject_runs(BASE, s, TASK_NAME)
        if not setfiles:
            print(f"{subject_id}: no .set files found, skipping.")
            continue

        for setfile in setfiles:
            print(f"\n  Run file: {setfile.name}")

            base_name = setfile.name[:-8]  # remove "_eeg.set"
            events_tsv = setfile.with_name(f"{base_name}_events.tsv")
            onsets = read_events_tsv(events_tsv)
            if onsets is None or len(onsets) == 0:
                print("   No stimulation events found, skipping run.")
                continue

            # Load full data (EEG + ESG + ECG + ENG + others)
            raw = mne.io.read_raw_eeglab(setfile, preload=False, verbose=False)

            # Load data to memory and convert to float32 to reduce RAM usage
            raw.load_data()
            raw._data = raw._data.astype(np.float32)

            # Channel selection based on channel type in the dataset:
            # clean all channels except stimulus/misc
            ch_types = raw.get_channel_types()
            ch_to_clean = [
                ch for ch, t in zip(raw.ch_names, ch_types)
                if t not in ("stim", "misc")
            ]

            print(f"   Total channels: {len(raw.ch_names)} | sfreq = {raw.info['sfreq']} Hz")
            print(f"   Channels to clean (all non-stim/misc): {len(ch_to_clean)}")
            print(f"   Number of stimuli: {len(onsets)}")

            # 3) PCHIP interpolation of the stimulation artifact on all analog channels
            interpolate_stim_artifact(
                raw,
                onsets,
                start_ms,
                end_ms,
                picks=ch_to_clean,
                n_pad=5,
            )

            # 4) Save artifact-cleaned data as .fif at 10 kHz
            out_subdir = OUT_DIR / subject_id
            out_subdir.mkdir(parents=True, exist_ok=True)

            m_run = re.search(r"run-(\d+)", setfile.name)
            run_id = int(m_run.group(1)) if m_run else 1

            out_fif = out_subdir / f"noStimart_10kHz_task-{TASK_NAME}_run-{run_id:02d}.fif"
            raw.save(out_fif, overwrite=True)
            print("   Saved:", out_fif)

            del raw

    print("\nFinished: stimulation artifact interpolated for all non-stim channels.")


if __name__ == "__main__":
    main()



