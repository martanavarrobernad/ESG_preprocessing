
"""
Paso 6: concatenar runs por condición y crear referencias TH6 / ventral.

Entrada:
  - ESG tras PCA-OBS: esg_1000Hz_ecgclean_obs/sub-XXX/...

Salida:
  - esg_step6_concat_ref/sub-XXX/<cond>_ref-TH6_concat.fif
      (los datos ESG tal y como fueron grabados: ya referenciados a TH6)
  - esg_step6_concat_ref/sub-XXX/<cond>_ref-VENTRAL_concat.fif
      (misma señal ESG, re-referenciada algebraicamente a AC o AL)

Importante:
  - En el dataset original, TH6 es el electrodo de referencia de hardware
    (no aparece como canal en raw.ch_names). Por tanto:
      * NO se puede restar "TH6" como canal.
      * El fichero ref-TH6 es simplemente el ESG limpio/concatenado.

Requiere:
  - CSV con canales malos (salida del paso 5):
    BASE / 'bad_esg_channels_manual.csv'
    con columnas: subject,run,bad_channels
    donde bad_channels es una lista separada por ';'
"""

from pathlib import Path
import re
import numpy as np
import pandas as pd
import mne

BASE = Path(r"C:\Users\navar\Desktop\ds004388-1.0.0")

# ESG ecg-clean (salida del paso 4 / 5)
ESG_ECGCLEAN_DIR = BASE / "esg_1000Hz_ecgclean_obs"

# Carpeta de salida para este paso
OUT_DIR = BASE / "esg_step6_concat_ref"
OUT_DIR.mkdir(exist_ok=True, parents=True)

TASK_NAME = "median"  # condición a procesar

# Etiqueta descriptiva de la referencia dorsal (no es un canal)
TH6_LABEL = "TH6"

# referencia ventral según condición
VENTRAL_REF_BY_COND = {
    "hand-mixed": "AC",
    "foot-mixed": "AL",
    # en tus datos, "median" es mano → AC
    "median": "AC",
}

# CSV con canales malos (puedes cambiar el nombre si usaste otro)
BAD_CSV = BASE / "bad_esg_channels_from_psd_clicks.csv"

# canales ESG (dorsales) que quieres conservar
ESG_CHANNELS = [
    "Iz", "SC1", "S3", "S4", "S5", "S6", "S7", "S8", "S9",
    "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19",
    "SC6",
]


# ---------------------------------------------------------------------
# Utilidades
# ---------------------------------------------------------------------
def load_bad_channels():
    """
    Lee CSV con columnas: subject,run,bad_channels
    donde bad_channels es una lista separada por ';'
    Devuelve: dict[(subject, run)] -> [lista de canales malos]
    """
    if not BAD_CSV.exists():
        print(f"⚠ No existe {BAD_CSV.name} → no se eliminarán canales.")
        return {}

    df = pd.read_csv(BAD_CSV)
    bad_dict = {}
    for _, row in df.iterrows():
        key = (row["subject"], int(row["run"]))
        if isinstance(row["bad_channels"], str) and row["bad_channels"].strip():
            chans = [ch.strip() for ch in row["bad_channels"].split(";")]
        else:
            chans = []
        bad_dict[key] = chans
    print(f"   ✓ Cargado CSV de canales malos: {BAD_CSV.name}")
    return bad_dict


def find_esg_clean_runs(subject: int):
    """Devuelve lista de FIF ESG ecg-clean para un sujeto."""
    subj = f"sub-{subject:03d}"
    subj_dir = ESG_ECGCLEAN_DIR / subj
    return sorted(
        subj_dir.glob(
            f"noStimart_sr1000Hz_all_task-{TASK_NAME}_run-*_ecgclean.fif"
        )
    )


def reref_esg(raw, esg_chs, ref_ch):
    """
    Re-referencia algebraicamente todos los canales esg_chs
    restando el canal ref_ch.

    raw: Raw MNE
    esg_chs: lista de nombres de canal ESG (sin incluir ref_ch)
    ref_ch: nombre de canal a usar como referencia (AC, AL, etc.)

    Devuelve: Raw nuevo, con misma estructura, pero datos ESG re-referenciados.
    """
    if ref_ch not in raw.ch_names:
        raise RuntimeError(f"Referencia {ref_ch} no está en raw.ch_names")

    raw_ref = raw.copy()
    ref_idx = raw_ref.ch_names.index(ref_ch)
    ref_data = raw_ref.get_data(picks=[ref_idx])[0]

    esg_idx = mne.pick_channels(raw_ref.ch_names, include=esg_chs)
    data = raw_ref.get_data()
    data[esg_idx, :] = data[esg_idx, :] - ref_data
    raw_ref._data = data
    return raw_ref


# ---------------------------------------------------------------------
# Paso 6 principal
# ---------------------------------------------------------------------
def step6_concat_and_reference(subjects=range(1, 10), condition_label="median"):
    bad_dict = load_bad_channels()

    for s in subjects:
        subject_id = f"sub-{s:03d}"
        fif_files = find_esg_clean_runs(s)
        if not fif_files:
            print(f"{subject_id}: sin ESG ecgclean para {TASK_NAME}, salto.")
            continue

        print(f"\n===== {subject_id} ({condition_label}) =====")
        raws = []
        runs = []

        for fif in fif_files:
            m = re.search(r"run-(\d+)", fif.name)
            run = int(m.group(1)) if m else 1
            runs.append(run)

            print(f"  Cargando {fif.name}")
            raw = mne.io.read_raw_fif(fif, preload=True, verbose="warning")

            # ESG presentes
            esg_ch_present = [ch for ch in ESG_CHANNELS if ch in raw.ch_names]

            # Referencia ventral (AC / AL) si existe
            ref_ventral = VENTRAL_REF_BY_COND.get(condition_label, None)
            keep_extra = []
            if ref_ventral and ref_ventral in raw.ch_names:
                keep_extra.append(ref_ventral)

            # Seleccionar sólo ESG + ventral (si está)
            picks = mne.pick_channels(
                raw.ch_names,
                include=sorted(set(esg_ch_present + keep_extra)),
            )
            raw.pick(picks)

            # Eliminar canales ruidosos de este run según CSV
            key = (subject_id, run)
            bad = bad_dict.get(key, [])
            bad = [ch for ch in bad if ch in raw.ch_names]
            if bad:
                print(f"   → Eliminando canales ruidosos (CSV): {bad}")
                raw.drop_channels(bad)

            raws.append(raw)

        if not raws:
            print("   ⚠ No hay datos concatenables (todo dropeado).")
            continue

        # Concatenar runs
        raw_concat = mne.concatenate_raws(raws)
        print(f"   Concatenado: duración total = {raw_concat.times[-1]:.1f} s")

        # Canales ESG finales tras dropear
        esg_ch_final = [ch for ch in ESG_CHANNELS if ch in raw_concat.ch_names]
        if not esg_ch_final:
            print("   ⚠ No quedan canales ESG tras eliminar ruidosos. Salto sujeto.")
            continue

        out_subdir = OUT_DIR / subject_id
        out_subdir.mkdir(exist_ok=True, parents=True)

        # ---------------- ref-TH6 (ya viene de hardware) ----------------
        # Guardamos sólo los canales ESG dorsales, tal cual.
        raw_th6 = raw_concat.copy().pick(esg_ch_final)
        out_th6 = out_subdir / f"{condition_label}_ref-{TH6_LABEL}_concat.fif"
        raw_th6.save(out_th6, overwrite=True)
        print(f"   ✔ Guardado TH6-ref (sin re-referencia adicional): {out_th6}")

        # ---------------- ref-VENTRAL (AC / AL) ----------------
        ref_ventral = VENTRAL_REF_BY_COND.get(condition_label, None)
        if ref_ventral and ref_ventral in raw_concat.ch_names:
            print(f"   → Re-referenciando ESG a canal ventral {ref_ventral}...")
            raw_vent = reref_esg(raw_concat, esg_ch_final, ref_ventral)
            # Nos quedamos sólo con ESG, ya en ref ventral
            raw_vent = raw_vent.pick(esg_ch_final)
            out_vent = out_subdir / f"{condition_label}_ref-{ref_ventral}_concat.fif"
            raw_vent.save(out_vent, overwrite=True)
            print(f"   ✔ Guardado ventral-ref ({ref_ventral}): {out_vent}")
        else:
            print(f"   ⚠ No se encontró canal ventral válido para {condition_label}.")
            print(f"      (Buscado: {VENTRAL_REF_BY_COND.get(condition_label, None)})")


if __name__ == "__main__":
    # ajusta 'subjects' y 'condition_label' según tus datos
    step6_concat_and_reference(subjects=range(1, 3), condition_label="median")

