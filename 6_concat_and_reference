# 6_concat_and_reference.py
"""
Paso 6: concatenar runs por condición y crear referencias TH6 / ventral.

Entrada:
  - ESG tras PCA-OBS: esg_1000Hz_ecgclean_obs/sub-XXX/...

Salida:
  - esg_step6_concat_ref/sub-XXX/<cond>_ref-TH6_concat.fif
  - esg_step6_concat_ref/sub-XXX/<cond>_ref-VENTRAL_concat.fif

Requiere:
  - CSV manual con canales malos (salida conceptual del paso 5):
    BASE / 'bad_esg_channels_manual.csv'
"""

from pathlib import Path
import re
import numpy as np
import pandas as pd
import mne

BASE = Path(r"C:\Users\navar\Desktop\ds004388-1.0.0")
ESG_ECGCLEAN_DIR = BASE / "esg_1000Hz_ecgclean_obs"
OUT_DIR = BASE / "esg_step6_concat_ref"
OUT_DIR.mkdir(exist_ok=True, parents=True)

TASK_NAME = "median"  # o la condición que estés procesando

# canal de referencia dorsal (grabación, TH6)
TH6_CH = "TH6"

# referencia ventral según condición (ajusta nombres según tu BIDS)
VENTRAL_REF_BY_COND = {
    "hand-mixed": "AC",
    "foot-mixed": "AL",
    # si tu "median" corresponde a mano, puedes mapearlo así:
    "median": "AC",
}

BAD_CSV = BASE / "bad_esg_channels_manual.csv"

# canales ESG (los que quieres conservar)
ESG_CHANNELS = [
    "Iz", "SC1", "S3", "S4", "S5", "S6", "S7", "S8", "S9",
    "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19",
    "SC6",
]


def load_bad_channels():
    """
    Lee CSV manual con columnas: subject,run,bad_channels
    donde bad_channels es una lista separada por ';'
    """
    if not BAD_CSV.exists():
        print("⚠ No existe bad_esg_channels_manual.csv → no se eliminarán canales.")
        return {}

    df = pd.read_csv(BAD_CSV)
    bad_dict = {}
    for _, row in df.iterrows():
        key = (row["subject"], int(row["run"]))
        if isinstance(row["bad_channels"], str) and row["bad_channels"].strip():
            chans = [ch.strip() for ch in row["bad_channels"].split(";")]
        else:
            chans = []
        bad_dict[key] = chans
    return bad_dict


def find_esg_clean_runs(subject: int):
    subj = f"sub-{subject:03d}"
    subj_dir = ESG_ECGCLEAN_DIR / subj
    return sorted(subj_dir.glob(f"noStimart_sr1000Hz_all_task-{TASK_NAME}_run-*_ecgclean.fif"))


def reref_esg(raw, esg_chs, ref_ch):
    """Resta el canal ref_ch a todos los esg_chs (re-referencia algebraica simple)."""
    if ref_ch not in raw.ch_names:
        raise RuntimeError(f"Referencia {ref_ch} no está en raw.ch_names")

    raw_ref = raw.copy()
    ref_idx = raw_ref.ch_names.index(ref_ch)
    ref_data = raw_ref.get_data(picks=[ref_idx])[0]

    esg_idx = mne.pick_channels(raw_ref.ch_names, include=esg_chs)
    data = raw_ref.get_data()
    data[esg_idx, :] = data[esg_idx, :] - ref_data
    raw_ref._data = data
    return raw_ref


def step6_concat_and_reference(subjects=range(1, 10), condition_label="median"):
    bad_dict = load_bad_channels()

    for s in subjects:
        subject_id = f"sub-{s:03d}"
        fif_files = find_esg_clean_runs(s)
        if not fif_files:
            print(f"{subject_id}: sin ESG ecgclean para {TASK_NAME}, salto.")
            continue

        print(f"\n===== {subject_id} =====")
        raws = []
        runs = []
        for fif in fif_files:
            m = re.search(r"run-(\d+)", fif.name)
            run = int(m.group(1)) if m else 1
            runs.append(run)

            print(f"  Cargando {fif.name}")
            raw = mne.io.read_raw_fif(fif, preload=True, verbose="warning")

            # Seleccionar sólo ESG + TH6 + ventral ref
            esg_ch_present = [ch for ch in ESG_CHANNELS if ch in raw.ch_names]
            keep_extra = [TH6_CH] if TH6_CH in raw.ch_names else []
            ref_ventral = VENTRAL_REF_BY_COND.get(condition_label, None)
            if ref_ventral and ref_ventral in raw.ch_names:
                keep_extra.append(ref_ventral)

            picks = mne.pick_channels(
                raw.ch_names,
                include=list(set(esg_ch_present + keep_extra))
            )
            raw.pick(picks)

            # Eliminar canales ruidosos (manual, paso 5)
            key = (subject_id, run)
            bad = bad_dict.get(key, [])
            bad = [ch for ch in bad if ch in raw.ch_names]
            if bad:
                print(f"   → Eliminando canales ruidosos (manual): {bad}")
                raw.drop_channels(bad)

            raws.append(raw)

        if not raws:
            print("   ⚠ No hay datos concatenables.")
            continue

        raw_concat = mne.concatenate_raws(raws)
        print(f"   Concatenado: duración total = {raw_concat.times[-1]:.1f} s")

        # ESG channels tras dropear
        esg_ch_final = [ch for ch in ESG_CHANNELS if ch in raw_concat.ch_names]
        if not esg_ch_final:
            print("   ⚠ No quedan canales ESG tras eliminar ruidosos.")
            continue

        # --- referencia TH6 ---
        if TH6_CH in raw_concat.ch_names:
            raw_th6 = reref_esg(raw_concat, esg_ch_final, TH6_CH)
            out_subdir = OUT_DIR / subject_id
            out_subdir.mkdir(exist_ok=True, parents=True)
            out_th6 = out_subdir / f"{condition_label}_ref-TH6_concat.fif"
            raw_th6.save(out_th6, overwrite=True)
            print(f"   ✔ Guardado TH6-ref: {out_th6}")
        else:
            print(f"   ⚠ No se encontró {TH6_CH}, no se guarda ref-TH6.")

        # --- referencia ventral ---
        ref_ventral = VENTRAL_REF_BY_COND.get(condition_label, None)
        if ref_ventral and ref_ventral in raw_concat.ch_names:
            raw_vent = reref_esg(raw_concat, esg_ch_final, ref_ventral)
            out_subdir = OUT_DIR / subject_id
            out_subdir.mkdir(exist_ok=True, parents=True)
            out_vent = out_subdir / f"{condition_label}_ref-{ref_ventral}_concat.fif"
            raw_vent.save(out_vent, overwrite=True)
            print(f"   ✔ Guardado ventral-ref ({ref_ventral}): {out_vent}")
        else:
            print(f"   ⚠ No ref ventral válida para {condition_label}.")


if __name__ == "__main__":
    # ajusta 'condition_label' si quieres usar hand-mixed / foot-mixed
    step6_concat_and_reference(subjects=range(1, 10), condition_label="median")
